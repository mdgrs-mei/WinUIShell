using Microsoft.CodeAnalysis;
using WinUIShell.ApiExporter;

namespace WinUIShell.Generator;

internal static class ObjectGenerator
{
    private static readonly Dictionary<string, ObjectDef> _objectDefs = [];

    public static void Generate(SourceProductionContext sourceProductionContext, Api api)
    {
        CreateObjectDefMap(api);

        foreach (var keyValuePair in _objectDefs)
        {
            ObjectDef objectDef = keyValuePair.Value;
            string filename = objectDef.GetSourceCodeFileName();
            string sourceCode = objectDef.Generate();
            sourceProductionContext.AddSource(filename, sourceCode);
        }

        DestroyObjectDefMap();
    }

    private static void CreateObjectDefMap(Api api)
    {
        foreach (var apiObjectDef in api.Objects)
        {
            ObjectDef objectDef = new(apiObjectDef);
            if (!objectDef.IsSupported())
                continue;

            var typeId = objectDef.Type.GetId();
            if (_objectDefs.ContainsKey(typeId))
            {
                throw new InvalidOperationException($"Duplicate object found: {typeId}");
            }
            _objectDefs[typeId] = objectDef;
        }
    }

    private static void DestroyObjectDefMap()
    {
        _objectDefs.Clear();
    }

    public static ObjectDef? GetObjectDef(TypeDef typeDef)
    {
        var typeId = typeDef.GetId();
        if (_objectDefs.TryGetValue(typeId, out var objectDef))
        {
            return objectDef;
        }
        return null;
    }

    public static void GenerateTypeMapping(SourceProductionContext sourceProductionContext, Api api)
    {
        var codeWriter = new CodeWriter();

        codeWriter.Append($$"""
            // <auto-generated/>
            #nullable enable

            namespace WinUIShell.Common;

            public sealed class ObjectTypeMapping : Singleton<ObjectTypeMapping>
            {
            """);

        codeWriter.IncrementIndent();
        codeWriter.Append($$"""
            private readonly Dictionary<string, string> _map = [];

            public ObjectTypeMapping()
            {
                foreach (var map in _list)
                {
                    _map.Add(map.Item1, map.Item2);
                    if (!_map.ContainsKey(map.Item2))
                    {
                        _map.Add(map.Item2, map.Item1);
                    }
                }
            }

            public string GetTargetTypeName<T>()
            {
                Type type = typeof(T);
                _ = TryGetTargetTypeName(type, out string? targetTypeName);
                if (targetTypeName is null)
                {
                    throw new InvalidOperationException($"Object type mapping not found for [{type.FullName}].");
                }
                return targetTypeName;
            }

            public bool TryGetTargetTypeName(Type sourceType, out string? targetTypeName)
            {
                var assemblyName = sourceType.Assembly.GetName().Name;
                if (sourceType.IsGenericType)
                {
                    if (!_map.TryGetValue($"{sourceType.FullName!.Split('[')[0]}, {assemblyName}", out string? thisName))
                    {
                        targetTypeName = null;
                        return false;
                    }

                    string[] thisNameAndAssembly = thisName.Split(", ");

                    List<string> argNames = [];
                    foreach (var argType in sourceType.GetGenericArguments())
                    {
                        if (!TryGetTargetTypeName(argType, out string? argTargetTypeName))
                        {
                            targetTypeName = null;
                            return false;
                        }
                        argNames.Add($"[{argTargetTypeName}]");
                    }

                    targetTypeName = $"{thisNameAndAssembly[0]}[{string.Join(", ", argNames)}], {thisNameAndAssembly[1]}";
                    return true;
                }
                else
                {
                    return _map.TryGetValue($"{sourceType.FullName}, {assemblyName}", out targetTypeName);
                }
            }

            private readonly List<(string, string)> _list = [
            """);

        codeWriter.IncrementIndent();

        foreach (var (systemTypeFullName, _) in Api.SystemTypes)
        {
            codeWriter.Append($"""
                ("{systemTypeFullName}, System.Private.CoreLib", "{systemTypeFullName}, System.Private.CoreLib"),
                """);
        }

        foreach (var apiObjectDef in api.Objects)
        {
            ObjectDef objectDef = new(apiObjectDef);
            if (!objectDef.IsSupported())
                continue;

            var ns = Generator.GetTargetNamespace(apiObjectDef.Namespace);
            var genericArgumentCount = apiObjectDef.Type.GenericTypeArguments is not null ? apiObjectDef.Type.GenericTypeArguments.Count : 0;
            string genericSuffix = (genericArgumentCount > 0) ? $"`{genericArgumentCount}" : "";

            codeWriter.Append($"""
                ("{ns}.{apiObjectDef.Name}{genericSuffix}, WinUIShell", "{apiObjectDef.FullName}"),
                """);
        }
        codeWriter.DecrementIndent();

        codeWriter.Append("];");
        codeWriter.DecrementIndent();

        codeWriter.Append("}");

        sourceProductionContext.AddSource($"ObjectTypeMapping.g.cs", codeWriter.ToString());
    }
}
