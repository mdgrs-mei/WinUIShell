using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace WinUIShell.Generator;

internal static class AttributeGenerator
{
    private static readonly string s_surpressMethodByNameAttributeName = "SurpressGeneratorMethodByNameAttribute";
    private static readonly Dictionary<string, SurpressedClass> s_surpressedClasses = [];

    private class SurpressedClass
    {
        private readonly HashSet<string> _methodNames = [];

        public void AddMethodName(string methodName)
        {
            _ = _methodNames.Add(methodName);
        }

        public bool IsSurpressed(string methodName)
        {
            return _methodNames.Contains(methodName);
        }
    }

    public static string SurpressMethodByNameAttributeFullName
    {
        get => $"WinUIShell.Generator.{s_surpressMethodByNameAttributeName}";
    }

    public static void Generate(IncrementalGeneratorPostInitializationContext postInitContext)
    {
        var source = $$"""
                // <auto-generated/>
                #nullable enable
                
                namespace WinUIShell.Generator;

                [global::System.AttributeUsage(
                    global::System.AttributeTargets.Class | global::System.AttributeTargets.Interface |
                    global::System.AttributeTargets.Method | global::System.AttributeTargets.Constructor,
                    AllowMultiple = false)]
                internal sealed class {{s_surpressMethodByNameAttributeName}} : global::System.Attribute
                {
                    public string[]? Names;

                    public {{s_surpressMethodByNameAttributeName}}(params string[] methodNames)
                    {
                        if (methodNames.Length > 0)
                        {
                            Names = methodNames;
                        }
                    } 
                }
                """;
        postInitContext.AddSource($"{s_surpressMethodByNameAttributeName}.g.cs", source);
    }

    public static void InitSurpressDictionary(ImmutableArray<GeneratorAttributeSyntaxContext> surpressMethodByNameAttributes)
    {
        foreach (GeneratorAttributeSyntaxContext attributeContext in surpressMethodByNameAttributes)
        {
            string? className = null;
            string[]? methodNames = null;
            if (attributeContext.TargetSymbol is IMethodSymbol)
            {
                className = attributeContext.TargetSymbol.ContainingType.ToString();
                methodNames = [attributeContext.TargetSymbol.Name];
            }
            else
            if (attributeContext.TargetSymbol is ITypeSymbol)
            {
                className = attributeContext.TargetSymbol.ToString();
                var surpressMethodAttributes = GetAttributeData(attributeContext, s_surpressMethodByNameAttributeName);

                foreach (var attribute in surpressMethodAttributes)
                {
                    if (attribute.ConstructorArguments.Length == 0)
                        continue;

                    var args = attribute.ConstructorArguments[0].Values;
                    methodNames = new string[args.Length];
                    for (int i = 0; i < args.Length; ++i)
                    {
                        methodNames[i] = RemoveEnclosingQuotes(args[i].ToCSharpString());
                    }
                }
            }

            if (className is null || methodNames is null)
                continue;

            if (!s_surpressedClasses.TryGetValue(className, out var surpressedClass))
            {
                surpressedClass = new();
                s_surpressedClasses.Add(className, surpressedClass);
            }

            foreach (string methodName in methodNames)
            {
                surpressedClass.AddMethodName(methodName);
            }
        }
    }

    private static AttributeData[] GetAttributeData(GeneratorAttributeSyntaxContext attributeContext, string attributeClassName)
    {
        List<AttributeData> attributes = [];
        foreach (var attribute in attributeContext.Attributes)
        {
            if (attribute is null)
                continue;

            if (attribute.AttributeClass is null)
                continue;

            if (attribute.AttributeClass.Name == attributeClassName)
            {
                attributes.Add(attribute);
            }
        }
        return [.. attributes];
    }

    private static string RemoveEnclosingQuotes(string input)
    {
        if (input.Length >= 2 &&
            input[0] == '\"' &&
            input[input.Length - 1] == '\"')
        {
            return input.Substring(1, input.Length - 2);
        }
        return input;
    }

    public static void TermSurpressDictionary()
    {
        s_surpressedClasses.Clear();
    }

    public static bool IsSurpressed(MethodDef methodDef, bool isInterfaceImplExplicitImplementation = false)
    {
        var className = methodDef.ObjectDef.Type.GetName();
        var methodName = methodDef.GetName(isInterfaceImplExplicitImplementation);

        if (!s_surpressedClasses.TryGetValue(className, out var surpressedClass))
            return false;

        return surpressedClass.IsSurpressed(methodName);
    }

    public static bool IsSurpressed(EventDef eventDef, bool isInterfaceImplExplicitImplementation = false)
    {
        var className = eventDef.ObjectDef.Type.GetName();
        var methodName = eventDef.GetMethodFullName(isInterfaceImplExplicitImplementation);

        if (!s_surpressedClasses.TryGetValue(className, out var surpressedClass))
            return false;

        return surpressedClass.IsSurpressed(methodName);
    }

    public static bool IsConstructorSurpressed(string className)
    {
        var methodName = ".ctor";
        if (!s_surpressedClasses.TryGetValue(className, out var surpressedClass))
            return false;

        return surpressedClass.IsSurpressed(methodName);
    }
}
